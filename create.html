<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>สร้าง/แก้ไขข้อมูลหลัก (v5.5 - รวมเครื่องมือเตรียมเนื้อหา)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { --primary-color: #3498db; --secondary-color: #95a5a6; --success-color: #27ae60; --danger-color: #e74c3c; --warning-color: #f39c12; --light-bg: #f0f2f5; --white-bg: #fff; --text-dark: #2c3e50; --text-light: #555; --border-color: #ddd; }
        body { font-family: 'Sarabun', sans-serif; background-color: var(--light-bg); color: var(--text-dark); line-height: 1.6; margin: 0; padding: 20px; }
        .container { max-width: 95%; margin: auto; background: var(--white-bg); padding: 20px 30px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-radius: 8px; }
        .header-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        h1 { color: var(--primary-color); margin-top: 0; }
        .master-controls { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; padding: 15px; background-color: #eaf1f7; border-radius: 8px; border: 1px solid var(--primary-color); }
        .master-controls label { font-weight: bold; color: var(--text-dark); }
        .master-controls input[type="text"], .master-controls input[type="number"] {
            padding: 8px 10px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.95rem; width: 100px;
        }
        .control-group { flex: 1; min-width: 150px; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid var(--border-color); padding: 10px; text-align: left; vertical-align: top; }
        th { background-color: var(--primary-color); color: white; }
        td.order-cell { text-align: center; width: 40px; }
        td:nth-child(2) { width: 40%; } /* Pali text column */
        textarea.pali-text-input, textarea.thai-text-input { width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1rem; resize: vertical; box-sizing: border-box; font-family: 'Sarabun', sans-serif;}
        input[type="text"], input[type="number"] { padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1rem; width: 90%; box-sizing: border-box; }
        
        .button-group { margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        button { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; transition: background-color 0.3s ease; }
        button.primary { background-color: var(--primary-color); color: white; }
        button.primary:hover { background-color: #2980b9; }
        button.secondary { background-color: var(--secondary-color); color: white; }
        button.secondary:hover { background-color: #7f8c8d; }
        button.success-btn { background-color: var(--success-color); color: white; }
        button.success-btn:hover { background-color: #229a54; }
        button.danger-btn { background-color: var(--danger-color); color: white; }
        button.danger-btn:hover { background-color: #c0392b; }
        button.warning-btn { background-color: var(--warning-color); color: white; }
        button.warning-btn:hover { background-color: #e67e22; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }

        .status-message { margin-top: 15px; padding: 10px; border-radius: 5px; text-align: center; font-weight: bold; display: none; }
        .status-success { background-color: #d4edda; color: #155724; border-color: #c3e6cb; border: 1px solid; }
        .status-warning { background-color: #fff3cd; color: #856404; border-color: #ffeeba; border: 1px solid; }
        .status-error { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; border: 1px solid; }
        .status-info { background-color: #e7f3fe; color: #0056b3; border-color: #b3d7ff; border: 1px solid; }

        /* New styles for the preparation view */
        #preparationView {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        #preparationView textarea {
            min-height: 250px;
        }
        #preparationView .button-group {
            justify-content: center;
        }
        #paliInputPageNum {
            width: 150px;
        }
        #tableView { /* Ensure this is properly styled to show/hide */
            display: none; /* Hidden by default, shown after preparation */
        }
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, deleteDoc, query, orderBy, limit, startAfter, writeBatch, serverTimestamp, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        
        // Your Firebase configuration (replace with your actual config)
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY", // <--- *** ใส่ API Key ของคุณที่นี่ ***
            authDomain: "YOUR_AUTH_DOMAIN",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_STORAGE_BUCKET",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements (Existing)
            const dom = {
                masterBookNameInput: document.getElementById('masterBookName'),
                masterBookPartInput: document.getElementById('masterBookPart'),
                masterPrefixInput: document.getElementById('masterPrefix'),
                masterGroupIdInput: document.getElementById('masterGroupId'),
                masterPageStartInput: document.getElementById('masterPageStart'),
                masterPageEndInput: document.getElementById('masterPageEnd'),
                masterParagraphNumInput: document.getElementById('masterParagraphNum'),
                addRowBtn: document.getElementById('addRowBtn'),
                createSaveBtn: document.getElementById('createSaveBtn'),
                prevPageBtn: document.getElementById('prevPageBtn'),
                nextPageBtn: document.getElementById('nextPageBtn'),
                currentPageSpan: document.getElementById('currentPage'),
                sentenceTableBody: document.getElementById('sentenceTableBody'),
                tableContainer: document.getElementById('tableContainer'),
                superEditModeToggle: document.getElementById('superEditModeToggle'),
                // New for table view switching
                goToPrepBtn: document.getElementById('goToPrepBtn'), // Button in Table View to go back to Prep View
            };

            // New DOM Elements for Preparation View
            const preparationView = document.getElementById('preparationView');
            const tableView = document.getElementById('tableView'); // Wrap existing table in this div
            const paliInputRaw = document.getElementById('paliInputRaw'); // Renamed from paliInput for clarity
            const paliInputPageNum = document.getElementById('paliInputPageNum');
            const organizeSpacesBtn = document.getElementById('organizeSpacesBtn');
            const combineLinesBtn = document.getElementById('combineLinesBtn');
            const splitSentenceBtn = document.getElementById('splitSentenceBtn');
            const startEditingBtn = document.getElementById('startEditingBtn'); // New button to move to table view
            const undoPrepBtn = document.getElementById('undoPrepBtn'); // Renamed for clarity
            const prepStatusMessage = document.getElementById('prepStatusMessage');

            // State Variables (Existing)
            let lastVisible = null;
            let firstVisible = null;
            let currentQueryLimit = 20; // Default limit
            let currentMode = 'normal'; // 'normal' or 'super-edit'

            // New State Variables for Preparation View
            let lastProcessedTextPrep = ""; // For undo in preparation
            let currentPrepMode = 'CLEAN_PALI_MODE'; // Initial mode for preparation flow
            let sentencesReadyForTable = []; // Array to hold sentences after splitting, before moving to table

            // Constants
            const HASH_KEY = 'processed_pali_hashes';

            // --- Utility Functions for Preparation View ---

            // Function to display status messages in preparation view
            function showPrepStatus(message, type = 'info') {
                prepStatusMessage.textContent = message;
                prepStatusMessage.className = 'status-message'; // Reset classes
                prepStatusMessage.style.display = 'block';
                if (type === 'success') {
                    prepStatusMessage.classList.add('status-success');
                } else if (type === 'warning') {
                    prepStatusMessage.classList.add('status-warning');
                } else if (type === 'error') {
                    prepStatusMessage.classList.add('status-error');
                } else {
                    prepStatusMessage.classList.add('status-info');
                }
            }

            function hidePrepStatus() {
                prepStatusMessage.style.display = 'none';
            }

            // Function to generate SHA-256 hash of a string
            async function generateSha256Hash(text) {
                const textEncoder = new TextEncoder();
                const data = textEncoder.encode(text);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hexHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hexHash;
            }

            // Function to load all stored hashes from localStorage
            function loadStoredHashes() {
                const hashesJson = localStorage.getItem(HASH_KEY);
                try {
                    return hashesJson ? new Set(JSON.parse(hashesJson)) : new Set();
                } catch (e) {
                    console.error("Error parsing stored hashes from localStorage:", e);
                    localStorage.removeItem(HASH_KEY); // Clear corrupt data
                    return new Set();
                }
            }

            // Function to save a new hash to localStorage
            function addHashToStorage(hash) {
                const storedHashes = loadStoredHashes();
                storedHashes.add(hash);
                localStorage.setItem(HASH_KEY, JSON.stringify(Array.from(storedHashes)));
            }

            // Function to check if a hash exists in localStorage
            function isHashStored(hash) {
                const storedHashes = loadStoredHashes();
                return storedHashes.has(hash);
            }

            // --- Core Text Processing Functions for Preparation View ---

            function processPaliTextForSpaces(text) {
                // แยกข้อความเป็นบรรทัดๆ เพื่อรักษาสภาพการขึ้นบรรทัดใหม่
                let lines = text.split(/\r?\n/); 
                let processedLines = [];

                lines.forEach(line => {
                    // 1. ทำการ trim ช่องว่างหน้าหลังของแต่ละบรรทัดก่อน
                    line = line.trim();

                    // 2. ✅ แปลง € เป็น ฐ และ § เป็น ญ
                    line = line.replace(/€/g, 'ฐ');
                    line = line.replace(/§/g, 'ญ');

                    // 3. ✅ จัดการ ฯเปฯ และ ฯลฯ เป็นคำธรรมดา ไม่ไปยุ่งกับช่องว่าง
                    // ใช้ placeholder เพื่อป้องกันการถูกประมวลผลช่องว่างผิดพลาด
                    const PE_PLACEHOLDER = '___PE___';
                    const LA_PLACEHOLDER = '___LA___';
                    line = line.replace(/ฯเปฯ/g, PE_PLACEHOLDER);
                    line = line.replace(/ฯลฯ/g, LA_PLACEHOLDER);

                    // 4. ลดช่องว่างหลายอันให้เหลือ 1 อัน (เฉพาะ space/tab, ไม่รวม newline)
                    line = line.replace(/[ \t]+/g, ' ');

                    // 5. ✅ จัดการให้หน้า ฯ มี 1 เคาะ และหลัง ฯ มี 2 เคาะ
                    // p1 คืออักขระก่อนหน้า ฯ, p2 คืออักขระหลัง ฯ
                    // (match, p1, p2) => ... เป็น callback function ของ replace
                    // มันจะรับข้อความที่ match ทั้งหมด (match), capture group 1 (p1), capture group 2 (p2)
                    line = line.replace(/(\S)?\s*ฯ\s*(\S)?/g, (match, p1, p2) => {
                        let result = '';
                        if (p1) result += p1;
                        result += ' ฯ'; // 1 เคาะหน้า ฯ
                        if (p2) result += '  ' + p2; // 2 เคาะหลัง ฯ
                        return result;
                    });
                    
                    // 6. ✅ จัดการให้ทุกคำห่างกัน 2 เคาะ (เฉพาะในบรรทัดเดียวกัน)
                    // แทนที่ช่องว่างเดี่ยวๆ (ที่ไม่ใช่ช่องว่างคู่ หรือช่องว่างรอบ ฯ) ด้วยช่องว่างคู่
                    // [^\sฯ] หมายถึง อักขระใดๆ ที่ไม่ใช่ช่องว่างและไม่ใช่ ฯ
                    line = line.replace(/([^\sฯ])\s([^\sฯ])/g, '$1  $2');
                    
                    // 7. แก้ไขช่องว่างรอบ ฯ อีกครั้ง เพื่อให้แน่ใจว่าถูกต้องตามกฎ 1-2 เคาะ
                    // ถ้ามีช่องว่างหน้า ฯ เกิน 1 ก็ลดเหลือ 1 (เช่น "คำ   ฯ" -> "คำ ฯ")
                    line = line.replace(/(\S)\s+ฯ/g, '$1 ฯ'); 
                    // ถ้ามีช่องว่างหลัง ฯ ไม่ใช่ 2 ก็ปรับเป็น 2 (เช่น "ฯคำ" -> "ฯ  คำ", "ฯ คำ" -> "ฯ  คำ", "ฯ   คำ" -> "ฯ  คำ")
                    line = line.replace(/ฯ\s*(\S)/g, 'ฯ  $1'); 

                    // 8. นำ placeholder กลับคืน
                    line = line.replace(new RegExp(PE_PLACEHOLDER, 'g'), 'ฯเปฯ');
                    line = line.replace(new RegExp(LA_PLACEHOLDER, 'g'), 'ฯลฯ');

                    processedLines.push(line);
                });

                return processedLines.join('\n'); // เชื่อมบรรทัดกลับด้วย newline เดิม
            }

            function combineAllLines(text) {
                // ฟังก์ชันนี้ยังคงเหมือนเดิม เพื่อใช้สำหรับรวมบรรทัดหลังจากจัดระเบียบแล้ว
                return text.replace(/[\r\n]+/g, ' ').trim();
            }

            function splitIntoSentences(text) {
                let sentences = [];
                // Split by 'ฯ' while keeping the delimiter
                // This will split "ประโยค1ฯประโยค2" into ["ประโยค1", "ฯ", "ประโยค2"]
                let tempParts = text.split(/(ฯ)/); 
                let currentSentence = '';
                for (let i = 0; i < tempParts.length; i++) {
                    currentSentence += tempParts[i];
                    if (tempParts[i] === 'ฯ') {
                        // If 'ฯ' is encountered, push the accumulated sentence (including 'ฯ')
                        sentences.push(currentSentence.trim());
                        currentSentence = ''; // Reset for the next sentence
                    }
                }
                // Add any remaining part after the last 'ฯ' or if no 'ฯ' was present
                if (currentSentence.trim().length > 0) {
                    sentences.push(currentSentence.trim());
                }

                // Further split by newlines (Enter key presses) within each resulting 'sentence'
                // This ensures that if the user did NOT combine lines, each physical line becomes a separate "sentence"
                // unless it's explicitly part of a ฯ-delimited one. This respects the user's manual line breaks.
                let finalSentences = [];
                sentences.forEach(s => {
                    const lines = s.split(/\n+/).filter(line => line.trim() !== ''); // Split by one or more newlines
                    lines.forEach(line => {
                        finalSentences.push(line.trim());
                    });
                });

                return finalSentences.filter(s => s.length > 0); // Filter out any empty strings
            }

            // --- UI State Management for Preparation View ---
            function updatePrepUIState() {
                paliInputRaw.readOnly = false;
                organizeSpacesBtn.disabled = true;
                combineLinesBtn.disabled = true;
                splitSentenceBtn.disabled = true;
                startEditingBtn.style.display = 'none'; // Hide by default
                undoPrepBtn.disabled = true;

                switch (currentPrepMode) {
                    case 'CLEAN_PALI_MODE':
                        if (paliInputRaw.value.trim().length > 0) {
                            organizeSpacesBtn.disabled = false;
                        }
                        break;
                    case 'POST_CLEAN_MODE':
                        organizeSpacesBtn.disabled = true; // After cleaning, this button is disabled
                        combineLinesBtn.disabled = false;
                        splitSentenceBtn.disabled = false;
                        undoPrepBtn.disabled = false;
                        break;
                    case 'SPLIT_DONE_MODE':
                        paliInputRaw.readOnly = true; // Lock text area after splitting
                        organizeSpacesBtn.disabled = true;
                        combineLinesBtn.disabled = true;
                        splitSentenceBtn.disabled = true;
                        startEditingBtn.style.display = 'inline-block'; // Show button to move to table
                        undoPrepBtn.disabled = false;
                        break;
                }
            }

            // --- Main Tool Functions (Existing and Modified) ---

            // Function to add a new row to the table
            // Modified to accept initial paliText and masterData for prep mode
            let nextAvailableLocalId = 1; // Used for new rows not yet in Firebase
            function addNewRow(tbody, id, paliText = '', thaiText = null, initialMasterData = null) {
                const newRow = tbody.insertRow();
                // If ID is from Firebase (string), use it. Otherwise, generate a local temporary ID.
                newRow.dataset.id = id || `temp-${nextAvailableLocalId++}`; 
                newRow.innerHTML = `
                    <td class="order-cell" data-order="${id}"></td>
                    <td><textarea class="pali-text-input" rows="3" placeholder="ข้อความบาลี">${paliText}</textarea></td>
                    <td><input type="text" class="group-id-input" value="${initialMasterData ? initialMasterData.masterGroupId : ''}"></td>
                    <td><input type="number" class="page-start-input" value="${initialMasterData ? initialMasterData.masterPageStart : ''}" min="1"></td>
                    <td><input type="number" class="page-end-input" value="${initialMasterData ? initialMasterData.masterPageEnd : ''}" min="1"></td>
                    <td><input type="number" class="paragraph-num-input" value="${initialMasterData ? initialMasterData.masterParagraphNum : ''}" min="1"></td>
                    <td>
                        <button class="add-below-btn success-btn">เพิ่ม</button>
                        <button class="delete-row-btn danger-btn">ลบ</button>
                    </td>
                `;
                // Add event listeners for new buttons in the row
                newRow.querySelector('.add-below-btn').addEventListener('click', (e) => addRowBelow(e.target.closest('tr')));
                newRow.querySelector('.delete-row-btn').addEventListener('click', (e) => deleteRow(e.target.closest('tr')));
                
                // Add input event listeners to trigger updateTableOrder
                newRow.querySelector('.pali-text-input').addEventListener('input', updateTableOrder);
                newRow.querySelector('.group-id-input').addEventListener('input', updateTableOrder);
                newRow.querySelector('.page-start-input').addEventListener('input', updateTableOrder);
                newRow.querySelector('.page-end-input').addEventListener('input', updateTableOrder);
                newRow.querySelector('.paragraph-num-input').addEventListener('input', updateTableOrder);

                // Set the focus to the new Pali text area if it's not pre-filled
                if (!paliText) {
                    newRow.querySelector('.pali-text-input').focus();
                }
                return newRow; // Return the new row
            }

            // Function to add a row below a specific row (existing)
            function addRowBelow(currentRow) {
                const tbody = dom.sentenceTableBody;
                
                let masterData = {};
                // If there's a current row, get its data as a starting point
                masterData.masterGroupId = currentRow.querySelector('.group-id-input')?.value || '';
                masterData.masterPageStart = currentRow.querySelector('.page-start-input')?.value || '';
                masterData.masterPageEnd = currentRow.querySelector('.page-end-input')?.value || '';
                masterData.masterParagraphNum = currentRow.querySelector('.paragraph-num-input')?.value || '';
                
                // Increment paragraph_num for the new row if not in super-edit mode
                if (currentMode !== 'super-edit') {
                    masterData.masterParagraphNum = parseInt(masterData.masterParagraphNum) + 1;
                }

                // Insert the new row directly after the current row
                const newRow = addNewRow(tbody, null, '', null, masterData); // Pass null for ID to generate local temp ID
                currentRow.after(newRow);
                updateTableOrder();
            }

            // Function to delete a row (existing)
            function deleteRow(row) {
                if (confirm('คุณต้องการลบแถวนี้หรือไม่?')) {
                    row.remove();
                    updateTableOrder();
                }
            }

            // Logic to get latest paragraph number and page numbers
            function getLastRowMasterData() {
                const lastRow = dom.sentenceTableBody.lastElementChild;
                let masterData = {};
                if (lastRow) {
                    masterData.masterGroupId = lastRow.querySelector('.group-id-input')?.value || '';
                    masterData.masterPageStart = lastRow.querySelector('.page-start-input')?.value || '';
                    masterData.masterPageEnd = lastRow.querySelector('.page-end-input')?.value || '';
                    masterData.masterParagraphNum = lastRow.querySelector('.paragraph-num-input')?.value || '';
                } else {
                    // Fallback to master inputs if no rows exist
                    masterData.masterGroupId = dom.masterGroupIdInput.value;
                    masterData.masterPageStart = dom.masterPageStartInput.value;
                    masterData.masterPageEnd = dom.masterPageEndInput.value;
                    masterData.masterParagraphNum = dom.masterParagraphNumInput.value;
                }
                return masterData;
            }

            // Initialize the tool (Existing, but modified)
            async function initializeTool() {
                // Get URL parameters (existing)
                const urlParams = new URLSearchParams(window.location.search);
                dom.masterBookNameInput.value = urlParams.get('bookName') || 'ไม่ระบุ';
                dom.masterBookPartInput.value = urlParams.get('bookPart') || '';
                dom.masterPrefixInput.value = urlParams.get('prefix') || '';

                // Initially show the preparation view
                tableView.style.display = 'none';
                preparationView.style.display = 'block';
                updatePrepUIState(); // Initial UI state for preparation view
                
                // Load existing data into the table, but keep table view hidden
                // We load it in background in case user wants to switch back to it
                await loadData(); // Load existing data into table (but table is hidden)
                updateTableOrder(); // Ensure initial order is correct
            }

            // --- Event Listeners for Preparation View ---

            paliInputRaw.addEventListener('input', updatePrepUIState);
            paliInputRaw.addEventListener('paste', () => { // Enable button on paste
                setTimeout(updatePrepUIState, 0); // Allow paste event to complete
            });

            organizeSpacesBtn.addEventListener('click', async () => {
                let rawText = paliInputRaw.value;
                if (!rawText.trim()) {
                    showPrepStatus('กรุณาวางเนื้อหาบาลีก่อน!', 'warning');
                    return;
                }

                lastProcessedTextPrep = rawText; // Save for undo

                let cleanedText = processPaliTextForSpaces(rawText);

                showPrepStatus('กำลังตรวจสอบความซ้ำซ้อน...', 'info');
                const currentHash = await generateSha256Hash(cleanedText);

                if (isHashStored(currentHash)) {
                    showPrepStatus('ข้อความนี้ (หลังจากจัดระเบียบแล้ว) เคยประมวลผลไปแล้ว! คุณสามารถดำเนินการต่อได้ หรือล้างแล้ววางข้อความใหม่', 'warning');
                } else {
                    addHashToStorage(currentHash);
                    showPrepStatus('จัดระเบียบช่องว่างสำเร็จ และบันทึกสถานะการประมวลผลแล้ว!', 'success');
                }

                paliInputRaw.value = cleanedText;
                currentPrepMode = 'POST_CLEAN_MODE';
                updatePrepUIState();
            });

            combineLinesBtn.addEventListener('click', () => {
                let text = paliInputRaw.value;
                if (!text.trim()) {
                    showPrepStatus('ไม่มีข้อความให้รวมบรรทัด!', 'warning');
                    return;
                }
                lastProcessedTextPrep = text; // Save for undo

                let combinedText = combineAllLines(text);
                paliInputRaw.value = combinedText;
                showPrepStatus('รวมบรรทัดสำเร็จ!', 'success');
                updatePrepUIState();
            });

            splitSentenceBtn.addEventListener('click', () => {
                let textToSplit = paliInputRaw.value;
                if (!textToSplit.trim()) {
                    showPrepStatus('ไม่มีข้อความให้แบ่งประโยค!', 'warning');
                    return;
                }
                lastProcessedTextPrep = textToSplit; // Save for undo

                sentencesReadyForTable = splitIntoSentences(textToSplit);
                
                if (sentencesReadyForTable.length === 0) {
                    showPrepStatus('ไม่พบประโยคที่สามารถแบ่งได้! โปรดตรวจสอบเนื้อหา.', 'error');
                    return;
                }

                showPrepStatus(`แบ่งประโยคสำเร็จ ${sentencesReadyForTable.length} ประโยค!`, 'success');
                currentPrepMode = 'SPLIT_DONE_MODE';
                updatePrepUIState();
                paliInputRaw.value = sentencesReadyForTable.join('\n---\n'); // Show split results for confirmation
                paliInputRaw.readOnly = true; // Lock text area after splitting
            });

            startEditingBtn.addEventListener('click', () => {
                if (sentencesReadyForTable.length === 0) {
                    showPrepStatus('ไม่มีประโยคที่แบ่งแล้วให้ส่ง!', 'error');
                    return;
                }

                // Clear existing table data if any, or append
                // For now, it will clear if there are any existing rows in the table body.
                // If you want to append, modify this logic.
                dom.sentenceTableBody.innerHTML = ''; 
                
                // Set master page number from input in prep view
                // Set initial values for master inputs
                dom.masterPageStartInput.value = paliInputPageNum.value;
                dom.masterPageEndInput.value = paliInputPageNum.value; 
                
                let currentParagraphNum = parseInt(dom.masterParagraphNumInput.value);
                // If master paragraph num is not set or 0, start from 1. Else, use its value.
                if (isNaN(currentParagraphNum) || currentParagraphNum === 0) {
                    currentParagraphNum = 1;
                }

                let currentGroupId = dom.masterGroupIdInput.value || ''; 

                sentencesReadyForTable.forEach((sentence, index) => {
                    const initialMasterData = {
                        masterGroupId: currentGroupId,
                        masterPageStart: paliInputPageNum.value,
                        masterPageEnd: paliInputPageNum.value,
                        masterParagraphNum: currentParagraphNum
                    };
                    addNewRow(dom.sentenceTableBody, null, sentence, null, initialMasterData); // Pass null for ID to generate local temp ID
                    currentParagraphNum++; // Increment paragraph num for next sentence
                });

                updateTableOrder();
                showPrepStatus(`นำเข้า ${sentencesReadyForTable.length} ประโยคสู่ตารางแล้ว!`, 'success');
                
                // Switch to table view
                preparationView.style.display = 'none';
                tableView.style.display = 'block';
                
                // Reset prep view for next use
                paliInputRaw.value = '';
                paliInputRaw.readOnly = false;
                paliInputPageNum.value = 1; // Reset page number
                currentPrepMode = 'CLEAN_PALI_MODE';
                hidePrepStatus();
                sentencesReadyForTable = []; // Clear array
                lastProcessedTextPrep = ""; // Clear undo history for prep
                updatePrepUIState(); // Reset preparation buttons
            });

            undoPrepBtn.addEventListener('click', () => {
                if (lastProcessedTextPrep !== "") {
                    paliInputRaw.value = lastProcessedTextPrep;
                    lastProcessedTextPrep = ""; 
                    sentencesReadyForTable = []; 

                    if (currentPrepMode === 'SPLIT_DONE_MODE') {
                        currentPrepMode = 'POST_CLEAN_MODE';
                        paliInputRaw.readOnly = false;
                        showPrepStatus('ยกเลิกการแบ่งประโยคแล้ว', 'info');
                    } else if (currentPrepMode === 'POST_CLEAN_MODE') {
                        currentPrepMode = 'CLEAN_PALI_MODE';
                        showPrepStatus('ยกเลิกการจัดระเบียบช่องว่างแล้ว', 'info');
                    }
                    hidePrepStatus();
                    updatePrepUIState();
                } else {
                    showPrepStatus('ไม่สามารถยกเลิกได้แล้ว หรือไม่มีการเปลี่ยนแปลงล่าสุด', 'warning');
                }
            });

            goToPrepBtn.addEventListener('click', () => {
                // Switch back to preparation view
                tableView.style.display = 'none';
                preparationView.style.display = 'block';
                
                // Clear prep view for a fresh start when returning
                paliInputRaw.value = '';
                paliInputRaw.readOnly = false;
                paliInputPageNum.value = 1; 
                currentPrepMode = 'CLEAN_PALI_MODE';
                hidePrepStatus();
                sentencesReadyForTable = [];
                lastProcessedTextPrep = "";
                updatePrepUIState();
            });


            // --- Existing Event Listeners (ensure they are still attached) ---
            dom.addRowBtn.addEventListener('click', () => {
                const masterData = getLastRowMasterData();
                
                // Increment paragraph_num if there's a last row and it's not in super-edit mode
                if (currentMode !== 'super-edit' && dom.sentenceTableBody.lastElementChild) {
                    masterData.masterParagraphNum = parseInt(masterData.masterParagraphNum) + 1;
                } else if (!dom.sentenceTableBody.lastElementChild) { // If no rows, use master inputs directly
                    masterData.masterGroupId = dom.masterGroupIdInput.value;
                    masterData.masterPageStart = dom.masterPageStartInput.value;
                    masterData.masterPageEnd = dom.masterPageEndInput.value;
                    masterData.masterParagraphNum = dom.masterParagraphNumInput.value;
                }

                addNewRow(dom.sentenceTableBody, null, '', null, masterData); // Pass null for ID to generate local temp ID
                updateTableOrder();
            });

            dom.createSaveBtn.addEventListener('click', saveData); // ปุ่มบันทึกข้อมูล
            
            // Toggle Super Edit Mode
            dom.superEditModeToggle.addEventListener('change', function() {
                currentMode = this.checked ? 'super-edit' : 'normal';
                if (currentMode === 'super-edit') {
                    alert('เข้าสู่โหมด Super Edit: จะไม่เพิ่มเลขย่อหน้าอัตโนมัติ');
                } else {
                    alert('ออกจากโหมด Super Edit: จะเพิ่มเลขย่อหน้าอัตโนมัติ');
                }
            });

            // Function to delete an item from Firebase (existing)
            async function deleteFirebaseDoc(docId) {
                if (confirm('คุณแน่ใจหรือไม่ว่าต้องการลบข้อมูลนี้ออกจากฐานข้อมูล?')) {
                    try {
                        await deleteDoc(doc(db, "pali_sentences", docId));
                        // Remove row from table
                        const rowToDelete = document.querySelector(`tr[data-id="${docId}"]`);
                        if (rowToDelete) {
                            rowToDelete.remove();
                        }
                        updateTableOrder(); // Re-order table rows
                        showPrepStatus('ลบข้อมูลสำเร็จ!', 'success');
                    } catch (error) {
                        console.error("Error removing document: ", error);
                        showPrepStatus(`เกิดข้อผิดพลาดในการลบ: ${error.message}`, 'error');
                    }
                }
            }

            // --- Pagination (Existing) ---
            async function loadData(direction = 'next') {
                dom.sentenceTableBody.innerHTML = '<tr><td colspan="7" style="text-align:center;">กำลังโหลดข้อมูล...</td></tr>';
                dom.prevPageBtn.disabled = true;
                dom.nextPageBtn.disabled = true;

                const selectedBookName = dom.masterBookNameInput.value;
                const selectedBookPart = dom.masterBookPartInput.value;
                const prefix = dom.masterPrefixInput.value;

                if (!selectedBookName || !prefix) {
                    dom.sentenceTableBody.innerHTML = '<tr><td colspan="7" style="text-align:center;">กรุณาเลือกชื่อหนังสือและ Prefix ในหน้าสารบัญกลางก่อน</td></tr>';
                    return;
                }

                let q;
                let baseQuery = query(
                    collection(db, "pali_sentences"),
                    orderBy("prefix"), 
                    orderBy("page_start", "asc"),
                    orderBy("paragraph_num", "asc"),
                    orderBy("group_id", "asc"),
                    orderBy("id", "asc") 
                );

                if (direction === 'next' && lastVisible) {
                    q = query(baseQuery, 
                              startAfter(lastVisible), 
                              limit(currentQueryLimit));
                } else if (direction === 'prev' && firstVisible) {
                    q = query(baseQuery, 
                              orderBy("id", "desc"), 
                              startAfter(firstVisible), 
                              limit(currentQueryLimit));
                } else {
                    q = query(baseQuery, limit(currentQueryLimit));
                }

                try {
                    const documentSnapshots = await getDocs(q);
                    
                    if (documentSnapshots.empty) {
                        dom.sentenceTableBody.innerHTML = '<tr><td colspan="7" style="text-align:center;">ไม่พบข้อมูลสำหรับหนังสือเล่มนี้ หรือไม่มีข้อมูลเพิ่มเติม.</td></tr>';
                        dom.prevPageBtn.disabled = true;
                        dom.nextPageBtn.disabled = true;
                        return;
                    }

                    dom.sentenceTableBody.innerHTML = ''; // Clear existing rows
                    let docs = documentSnapshots.docs;

                    if (direction === 'prev') {
                        docs = docs.reverse();
                    }

                    const firstDoc = docs[0];
                    const lastDoc = docs[docs.length - 1];

                    const prevPageQuery = query(baseQuery, limit(1), orderBy("id", "desc"), startAfter(firstDoc));
                    const prevSnapshot = await getDocs(prevPageQuery);
                    dom.prevPageBtn.disabled = prevSnapshot.empty;

                    const nextPageQuery = query(baseQuery, limit(1), startAfter(lastDoc));
                    const nextSnapshot = await getDocs(nextPageQuery);
                    dom.nextPageBtn.disabled = nextSnapshot.empty;

                    firstVisible = docs[0];
                    lastVisible = docs[docs.length - 1];
                    
                    docs.forEach(docSnapshot => {
                        const data = docSnapshot.data();
                        const docId = docSnapshot.id; // Use Firebase doc ID for table row dataset.id
                        addNewRow(dom.sentenceTableBody, docId, data.pali_text, data.thai_text, {
                            masterGroupId: data.group_id,
                            masterPageStart: data.page_start,
                            masterPageEnd: data.page_end,
                            masterParagraphNum: data.paragraph_num
                        });
                    });
                    
                    updateTableOrder(); 
                } catch (error) {
                    console.error("Error loading data: ", error);
                    dom.sentenceTableBody.innerHTML = `<tr><td colspan="7" style="text-align:center; color: var(--danger-color);">เกิดข้อผิดพลาดในการโหลดข้อมูล: ${error.message}</td></tr>`;
                    dom.prevPageBtn.disabled = true;
                    dom.nextPageBtn.disabled = true;
                }
            }

            // Function to update the row numbers in the first column
            function updateTableOrder() {
                Array.from(dom.sentenceTableBody.rows).forEach((row, index) => {
                    row.querySelector('.order-cell').textContent = index + 1;
                });
            }

            // Save data to Firebase
            async function saveData() {
                dom.createSaveBtn.disabled = true;
                showPrepStatus('กำลังบันทึกข้อมูล...', 'info'); 

                try {
                    const batch = writeBatch(db);
                    const rows = Array.from(dom.sentenceTableBody.rows);
                    let hasError = false;

                    for (const row of rows) {
                        const docId = row.dataset.id; // Use the existing docId or temp ID
                        const paliText = row.querySelector('.pali-text-input')?.value.trim();
                        const groupId = row.querySelector('.group-id-input')?.value.trim();
                        const pageStart = parseInt(row.querySelector('.page-start-input')?.value) || 0;
                        const pageEnd = parseInt(row.querySelector('.page-end-input')?.value) || 0;
                        const paragraphNum = parseInt(row.querySelector('.paragraph-num-input')?.value) || 0;

                        if (!paliText || !groupId || pageStart === 0 || pageEnd === 0 || paragraphNum === 0) {
                            showPrepStatus('ข้อมูลไม่สมบูรณ์ในบางแถว (บาลี, Group ID, หน้าเริ่มต้น/สิ้นสุด, ย่อหน้า ต้องไม่ว่างเปล่าหรือเป็น 0)', 'error');
                            hasError = true;
                            break;
                        }

                        const data = {
                            book_name: dom.masterBookNameInput.value,
                            book_part: dom.masterBookPartInput.value,
                            prefix: dom.masterPrefixInput.value,
                            pali_text: paliText,
                            group_id: groupId,
                            page_start: pageStart,
                            page_end: pageEnd,
                            paragraph_num: paragraphNum,
                            last_modified: serverTimestamp()
                        };

                        let docRef;
                        if (docId && !docId.startsWith('temp-')) { // Existing Firebase document
                            docRef = doc(db, "pali_sentences", docId);
                        } else { // New document, Firebase will auto-generate ID
                            docRef = doc(collection(db, "pali_sentences")); 
                        }
                        
                        batch.set(docRef, data, { merge: true }); 
                    }

                    if (hasError) {
                        dom.createSaveBtn.disabled = false;
                        return;
                    }

                    await batch.commit();
                    showPrepStatus('บันทึกข้อมูลสำเร็จ! กำลังโหลดข้อมูลล่าสุด...', 'success');
                    dom.createSaveBtn.disabled = false;
                    
                    // Reload data to reflect saved changes and get actual Firebase IDs for new rows
                    await loadData();

                } catch (error) {
                    showPrepStatus(`บันทึกไม่สำเร็จ: ${error.message}`, 'error');
                    console.error("Error saving data: ", error);
                    dom.createSaveBtn.disabled = false;
                }
            }


            // --- Initial Setup ---
            initializeTool();
        });
    </script>
</head>
<body>
    <div class="container">
        <div class="header-bar">
            <h1>สร้าง/แก้ไขข้อมูลหลักบาลี</h1>
            <div>
                <button id="goToPrepBtn" class="secondary">กลับไปหน้าเตรียมเนื้อหา</button>
            </div>
        </div>

        <div id="preparationView">
            <h2>1. เตรียมเนื้อหาบาลีจากต้นฉบับ</h2>
            <div class="form-group">
                <label for="paliInputRaw">วางเนื้อหาบาลีทั้งหน้า:</label>
                <textarea id="paliInputRaw" rows="15" placeholder="วางเนื้อหาบาลีที่นี่..."></textarea>
            </div>

            <div class="form-group">
                <label for="paliInputPageNum">เลขหน้าเริ่มต้น (สำหรับหน้านี้):</label>
                <input type="number" id="paliInputPageNum" placeholder="ใส่เลขหน้า" min="1" value="1">
            </div>

            <div class="button-group">
                <button id="organizeSpacesBtn" class="primary">จัดระเบียบช่องว่าง</button>
                <button id="combineLinesBtn" class="primary">รวมบรรทัด</button>
                <button id="splitSentenceBtn" class="primary">แบ่งประโยค</button>
                <button id="startEditingBtn" class="success-btn" style="display: none;">เริ่มแก้ไขข้อมูลในตาราง</button>
                <button id="undoPrepBtn" class="secondary">ยกเลิก (ขั้นตอนเตรียมเนื้อหา)</button>
            </div>
            <div id="prepStatusMessage" class="status-message"></div>
        </div>

        <div id="tableView">
            <h2>2. กำหนดรายละเอียดประโยคในตาราง</h2>
            <div class="master-controls">
                <div class="control-group">
                    <label for="masterBookName">ชื่อหนังสือ:</label>
                    <input type="text" id="masterBookName" readonly>
                </div>
                <div class="control-group">
                    <label for="masterBookPart">เล่ม:</label>
                    <input type="text" id="masterBookPart" readonly>
                </div>
                <div class="control-group">
                    <label for="masterPrefix">Prefix (รหัสประจำ):</label>
                    <input type="text" id="masterPrefix" readonly>
                </div>
                <div class="control-group">
                    <label for="masterGroupId">Group ID เริ่มต้น:</label>
                    <input type="text" id="masterGroupId" value="">
                </div>
                <div class="control-group">
                    <label for="masterPageStart">หน้าเริ่มต้น:</label>
                    <input type="number" id="masterPageStart" min="1" value="1">
                </div>
                <div class="control-group">
                    <label for="masterPageEnd">หน้าสิ้นสุด:</label>
                    <input type="number" id="masterPageEnd" min="1" value="1">
                </div>
                <div class="control-group">
                    <label for="masterParagraphNum">ย่อหน้าเริ่มต้น:</label>
                    <input type="number" id="masterParagraphNum" min="1" value="1">
                </div>
                <div class="control-group">
                    <label>Super Edit Mode:</label>
                    <input type="checkbox" id="superEditModeToggle">
                </div>
            </div>

            <div class="button-group">
                <button id="addRowBtn" class="success-btn">เพิ่มแถวใหม่</button>
                <button id="createSaveBtn" class="primary">บันทึกข้อมูลทั้งหมด</button>
                <button id="prevPageBtn" class="secondary">หน้าก่อนหน้า</button>
                <button id="nextPageBtn" class="secondary">หน้าถัดไป</button>
                <span id="currentPage" style="margin-left: 10px;"></span>
            </div>
            
            <div id="tableContainer">
                <table>
                    <thead>
                        <tr>
                            <th>ลำดับ</th>
                            <th>ข้อความบาลี</th>
                            <th>Group ID</th>
                            <th>หน้าเริ่มต้น</th>
                            <th>หน้าสิ้นสุด</th>
                            <th>ย่อหน้า</th>
                            <th>การจัดการ</th>
                        </tr>
                    </thead>
                    <tbody id="sentenceTableBody">
                        </tbody>
                </table>
            </div>
        </div>
    </div>
</body>
</html>